#!/usr/bin/env python3
"""
Karaoke-style subtitle generator for ASS format.
Generates word-by-word highlighting for ELL (English Language Learner) content.
"""

import logging
from pathlib import Path
from typing import List, Dict, Any

logger = logging.getLogger(__name__)


class KaraokeGenerator:
    """Generate ASS format subtitles with karaoke word highlighting."""

    def __init__(self, style_config: Dict[str, Any]):
        """
        Initialize karaoke generator with style configuration.

        Args:
            style_config: Dictionary containing:
                - fontname: Font family (e.g., 'Arial')
                - fontsize: Font size in pixels (e.g., 32)
                - primary_color: Color for current/highlighted word (e.g., '&H0000FFFF' for yellow)
                - secondary_color: Color for unread words (e.g., '&H00FFFFFF' for white)
                - outline: Outline width (e.g., 3)
                - shadow: Shadow depth (e.g., 2)
                - alignment: Text alignment (2 = bottom center)
                - margin_v: Vertical margin in pixels (e.g., 80)
                
        Note: ASS karaoke format uses {\k##} tags where:
            - SecondaryColour = color BEFORE karaoke timing (unread words)
            - PrimaryColour = color AFTER karaoke timing starts (currently being read)
        """
        self.style = style_config
        logger.info(f"Initialized KaraokeGenerator with font: {style_config['fontname']} {style_config['fontsize']}px")

    def _format_ass_timestamp(self, seconds: float) -> str:
        """
        Format seconds as ASS timestamp: H:MM:SS.CC (centiseconds)

        Args:
            seconds: Time in seconds

        Returns:
            Formatted timestamp string
        """
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        secs = int(seconds % 60)
        centiseconds = int((seconds % 1) * 100)

        return f"{hours}:{minutes:02d}:{secs:02d}.{centiseconds:02d}"

    def _generate_karaoke_line(self, words: List[Dict[str, Any]], line_start: float, line_end: float) -> str:
        """
        Generate karaoke tags for a subtitle line.
        
        CRITICAL: Karaoke duration includes the word PLUS any gap until the next word starts.
        This ensures the highlighting stays synced with actual speech timing.

        Args:
            words: List of word dictionaries with 'word', 'start', 'end' keys
            line_start: Start time of the entire line
            line_end: End time of the entire line

        Returns:
            Formatted karaoke text with timing tags
        """
        if not words:
            return ""

        karaoke_text = ""

        for i, word in enumerate(words):
            # Calculate duration INCLUDING gap until next word
            # This is the time from this word's start to the next word's start
            # (or to line end for the last word)
            if i < len(words) - 1:
                # Duration = time until next word starts
                duration = words[i + 1]['start'] - word['start']
            else:
                # Last word: duration = time until line ends
                duration = line_end - word['start']
            
            # Convert to centiseconds (1/100th of a second)
            duration_cs = int(duration * 100)

            # Ensure minimum duration of 10 centiseconds (0.1 seconds) for visibility
            duration_cs = max(10, duration_cs)

            # Clean up the word text (remove extra spaces)
            word_text = word['word'].strip()

            # Add karaoke tag
            karaoke_text += f"{{\\k{duration_cs}}}{word_text}"

            # Add space between words (except for the last word)
            if i < len(words) - 1:
                karaoke_text += " "

        return karaoke_text

    def _generate_ass_header(self) -> str:
        """
        Generate ASS file header with script info and style definitions.

        Returns:
            ASS header string
        """
        header = """[Script Info]
; Karaoke-style subtitles for ELL (English Language Learner) content
; Generated by Phase 5.5 Subtitle Generator with Karaoke Support
ScriptType: v4.00+
PlayResX: 1920
PlayResY: 1080
WrapStyle: 0
ScaledBorderAndShadow: yes

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,{fontname},{fontsize},{primary_color},{secondary_color},{outline_color},{back_color},{bold},{italic},{underline},{strikeout},{scale_x},{scale_y},{spacing},{angle},{border_style},{outline},{shadow},{alignment},{margin_l},{margin_r},{margin_v},{encoding}

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
""".format(
            fontname=self.style['fontname'],
            fontsize=self.style['fontsize'],
            primary_color=self.style['primary_color'],  # Yellow (currently being read/highlighted)
            secondary_color=self.style['secondary_color'],  # White (not yet read)
            outline_color='&H00000000',  # Black outline
            back_color='&H00000000',  # Black background (transparent)
            bold=1,  # Bold text
            italic=0,
            underline=0,
            strikeout=0,
            scale_x=100,
            scale_y=100,
            spacing=0,
            angle=0,
            border_style=1,  # Outline + drop shadow
            outline=self.style['outline'],
            shadow=self.style['shadow'],
            alignment=self.style['alignment'],  # 2 = bottom center
            margin_l=10,
            margin_r=10,
            margin_v=self.style['margin_v'],
            encoding=1  # Default encoding
        )

        return header

    def generate_ass(self, segments: List[Dict[str, Any]], output_path: Path) -> Dict[str, Any]:
        """
        Generate ASS format subtitles with karaoke word-level highlighting.

        Args:
            segments: List of segment dictionaries, each containing:
                - 'start': Start time in seconds
                - 'end': End time in seconds
                - 'text': Subtitle text
                - 'words': List of word dictionaries (if available)
            output_path: Path where ASS file should be saved

        Returns:
            Dictionary with generation statistics
        """
        logger.info(f"Generating karaoke ASS file: {output_path}")

        # Generate header
        ass_content = self._generate_ass_header()

        # Process segments
        total_words = 0
        word_durations = []

        for seg in segments:
            # Check if word-level data is available
            if 'words' in seg and seg['words']:
                # Use FIRST WORD start time as line start (not segment start)
                # This ensures karaoke timing matches actual speech
                first_word_start = seg['words'][0]['start']
                last_word_end = seg['words'][-1]['end']
                
                start_time = self._format_ass_timestamp(first_word_start)
                end_time = self._format_ass_timestamp(last_word_end)
                
                # Generate karaoke line with word-level timing
                karaoke_text = self._generate_karaoke_line(seg['words'], first_word_start, last_word_end)
                total_words += len(seg['words'])

                # Calculate average word duration for this segment
                for word in seg['words']:
                    word_durations.append(word['end'] - word['start'])
            else:
                # Fallback: Use plain text without karaoke tags
                start_time = self._format_ass_timestamp(seg['start'])
                end_time = self._format_ass_timestamp(seg['end'])
                karaoke_text = seg['text']
                logger.warning(f"No word-level data for segment at {seg['start']:.2f}s - using plain text")

            # Format dialogue line
            # Format: Dialogue: Layer,Start,End,Style,Name,MarginL,MarginR,MarginV,Effect,Text
            dialogue_line = f"Dialogue: 0,{start_time},{end_time},Default,,0,0,0,,{karaoke_text}\n"
            ass_content += dialogue_line

        # Write to file
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(ass_content)

        # Calculate statistics
        avg_word_duration = sum(word_durations) / len(word_durations) if word_durations else 0

        stats = {
            'total_segments': len(segments),
            'total_words': total_words,
            'avg_word_duration': avg_word_duration,
            'output_path': str(output_path)
        }

        logger.info(f"Karaoke ASS generation complete:")
        logger.info(f"  Segments: {stats['total_segments']}")
        logger.info(f"  Words: {stats['total_words']}")
        logger.info(f"  Avg word duration: {stats['avg_word_duration']:.3f}s")

        return stats


def format_ass_timestamp(seconds: float) -> str:
    """
    Public utility function to format seconds as ASS timestamp.

    Args:
        seconds: Time in seconds

    Returns:
        Formatted timestamp string (H:MM:SS.CC)
    """
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    centiseconds = int((seconds % 1) * 100)

    return f"{hours}:{minutes:02d}:{secs:02d}.{centiseconds:02d}"
