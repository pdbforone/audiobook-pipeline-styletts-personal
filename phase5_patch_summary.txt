Summary:
- Ensured FFmpeg failure diagnostics are always written to disk (under `phase5_enhancement/logs/` with multiple fallbacks) before any error escapes `run_ffmpeg()`. The RuntimeError now includes exit code, command, diagnostics path, and a stderr preview.
- Hardened notification handling in `main()` error handlers: all uses of `args.play_notification` are protected via `getattr(args, "play_notification", False)` and `play_success_sound()` is wrapped in try/except so notification failures cannot raise during error handling.
- Added a missing `import datetime` used to create UTC timestamps for log filenames.

Unified diff (file: phase5_enhancement/src/phase5_enhancement/main.py)
--- a/phase5_enhancement/src/phase5_enhancement/main.py
+++ b/phase5_enhancement/src/phase5_enhancement/main.py
@@
 import time
 from pathlib import Path
+import datetime
@@
 def run_ffmpeg(cmd: list[str], desc: str) -> None:
     """Run an ffmpeg command and raise on failure.
 
     On failure, capture stdout/stderr, write a timestamped failure log under
     `phase5_enhancement/logs/` and include command/exit-code/stderr-preview in
     the raised RuntimeError. This improves diagnostics while preserving the
     original failure semantics.
     """
-    # Run ffmpeg and capture output
-    result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
-    if result.returncode != 0:
-        # Prepare diagnostics
-        try:
-            pkg_root = Path(__file__).resolve().parents[2]
-        except Exception:
-            pkg_root = Path.cwd()
-        logs_dir = pkg_root / "logs"
-        try:
-            logs_dir.mkdir(parents=True, exist_ok=True)
-        except Exception:
-            # Non-fatal: fall back to temp dir
-            logs_dir = Path(tempfile.gettempdir())
-
-        timestamp = datetime.datetime.utcnow().strftime("%Y%m%dT%H%M%SZ")
-        pid = os.getpid()
-        safe_desc = desc.replace(" ", "_").replace('/', '_')
-        log_name = f"ffmpeg_failure_{safe_desc}_{timestamp}_{pid}.log"
-        log_path = logs_dir / log_name
-
-        # Create a compact preview of stderr (first 200 lines)
-        stderr_lines = (result.stderr or "").splitlines()
-        stderr_preview = "\n".join(stderr_lines[:200])
-        stdout_preview = "\n".join((result.stdout or "").splitlines()[:50])
-
-        # Write full diagnostics to the file
-        try:
-            with open(log_path, "w", encoding="utf-8") as fh:
-                fh.write(f"FFmpeg command: {' '.join(cmd)}\n")
-                fh.write(f"Exit code: {result.returncode}\n")
-                fh.write("\n--- STDOUT (first 200 lines) ---\n")
-                fh.write(stdout_preview + "\n")
-                fh.write("\n--- STDERR (first 200 lines) ---\n")
-                fh.write(stderr_preview + "\n")
-                # If stderr longer, note truncated
-                if len(stderr_lines) > 200:
-                    fh.write(f"\n... (stderr truncated, total lines={len(stderr_lines)})\n")
-        except Exception as e:
-            logger.warning("Failed to write ffmpeg diagnostics log: %s", e)
-
-        # Log summary to configured logger (tail for quick console visibility)
-        logger.error("FFmpeg %s failed (exit %s). Diagnostics written to: %s", desc, result.returncode, str(log_path))
-        logger.error("FFmpeg stderr (preview): %s", stderr_preview[:3000])
-
-        # Raise with contextual info including path to diagnostics log and a stderr preview
-        raise RuntimeError(
-            f"FFmpeg {desc} failed (exit {result.returncode}). "
-            f"See ffmpeg diagnostics: {log_path} \n" 
-            f"stderr preview:\n{stderr_preview[:3000]}"
-        )
+    # Run ffmpeg and capture output
+    result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
+    if result.returncode != 0:
+        # Prepare diagnostics and ensure a log is written no matter what.
+        try:
+            pkg_root = Path(__file__).resolve().parents[2]
+        except Exception:
+            pkg_root = Path.cwd()
+
+        primary_logs_dir = pkg_root / "logs"
+        fallback_dirs = [Path(tempfile.gettempdir()), Path.cwd()]
+
+        # Try to create the primary logs directory; if that fails, we'll try fallbacks
+        try:
+            primary_logs_dir.mkdir(parents=True, exist_ok=True)
+            logs_dir = primary_logs_dir
+        except Exception:
+            logs_dir = None
+
+        timestamp = datetime.datetime.utcnow().strftime("%Y%m%dT%H%M%SZ")
+        pid = os.getpid()
+        safe_desc = desc.replace(" ", "_").replace('/', '_')
+        log_name = f"ffmpeg_failure_{safe_desc}_{timestamp}_{pid}.log"
+
+        stderr_text = result.stderr or ""
+        stdout_text = result.stdout or ""
+
+        # Create previews
+        stderr_lines = stderr_text.splitlines()
+        stderr_preview = "\n".join(stderr_lines[:200])
+        stdout_preview = "\n".join(stdout_text.splitlines()[:50])
+
+        # Attempt to write diagnostics to the primary logs dir, otherwise fall back
+        last_exc = None
+        log_path = None
+        write_contents = (
+            f"FFmpeg command: {' '.join(cmd)}\n"
+            f"Exit code: {result.returncode}\n"
+            "\n--- STDOUT (preview) ---\n"
+            f"{stdout_preview}\n"
+            "\n--- STDERR (preview) ---\n"
+            f"{stderr_preview}\n"
+        )
+
+        try_locations = []
+        if logs_dir is not None:
+            try_locations.append(logs_dir)
+        try_locations.extend(fallback_dirs)
+
+        for base in try_locations:
+            try:
+                base.mkdir(parents=True, exist_ok=True)
+            except Exception:
+                # mkdir may fail for fallback dirs on rare systems; ignore and try writing
+                pass
+            candidate = base / log_name
+            try:
+                with open(candidate, "w", encoding="utf-8") as fh:
+                    fh.write(write_contents)
+                    # If stderr was long, append a note about truncation
+                    if len(stderr_lines) > 200:
+                        fh.write(f"\n... (stderr truncated, total lines={len(stderr_lines)})\n")
+                log_path = candidate
+                break
+            except Exception as exc:  # noqa: BLE001 - keep writing resilient
+                last_exc = exc
+                continue
+
+        # If we couldn't write any file, create a fallback message and include stderr snippet
+        if log_path is None:
+            # As a last resort, attempt to write a minimal file in tempfile
+            try:
+                candidate = Path(tempfile.gettempdir()) / log_name
+                with open(candidate, "w", encoding="utf-8") as fh:
+                    fh.write(write_contents)
+                log_path = candidate
+            except Exception:
+                # Nothing more we can do; ensure we still raise with stderr preview inline
+                raise RuntimeError(
+                    f"FFmpeg {desc} failed (exit {result.returncode}). "
+                    f"Could not write diagnostics log (attempted locations). "
+                    f"stderr preview:\n{stderr_preview[:3000]}"
+                )
+
+        # At this point, diagnostics have been written to `log_path`.
+        # Log a short summary for console visibility.
+        try:
+            logger.error(
+                "FFmpeg %s failed (exit %s). Diagnostics written to: %s",
+                desc,
+                result.returncode,
+                str(log_path),
+            )
+            logger.error("FFmpeg stderr (preview): %s", stderr_preview[:3000])
+        except Exception:
+            # Logging must not prevent raising the runtime error
+            pass
+
+        # Finally raise with contextual info including path to diagnostics log and a stderr preview
+        raise RuntimeError(
+            f"FFmpeg {desc} failed (exit {result.returncode}). "
+            f"See ffmpeg diagnostics: {log_path} \n"
+            f"stderr preview:\n{stderr_preview[:3000]}"
+        )
@@
-    except ValidationError as e:
-        logger.error(f"Configuration validation failed: {e}")
-        play_notification = getattr(args, "play_notification", False)
-        if play_notification:
-            play_success_sound()
-        return 1
-    except Exception as e:
-        logger.error(f"Unexpected error: {e}")
-        import traceback
-        traceback.print_exc()
-        play_notification = getattr(args, "play_notification", False)
-        if play_notification:
-            play_success_sound()
-        return 1
+    except ValidationError as e:
+        logger.error(f"Configuration validation failed: {e}")
+        play_notification = getattr(args, "play_notification", False)
+        if play_notification:
+            try:
+                play_success_sound()
+            except Exception as exc:
+                logger.warning("play_success_sound failed during error handling: %s", exc)
+        return 1
+    except Exception as e:
+        logger.error(f"Unexpected error: {e}")
+        import traceback
+        traceback.print_exc()
+        play_notification = getattr(args, "play_notification", False)
+        if play_notification:
+            try:
+                play_success_sound()
+            except Exception as exc:
+                logger.warning("play_success_sound failed during error handling: %s", exc)
+        return 1
